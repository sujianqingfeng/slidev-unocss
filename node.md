# Unocss

<!--
- unocss是什么
- 提及原子化
-->


# Atomic CSS
<!-- 
- 定义： 是一种编写css的方法，将属性及属性值拆分成独立的、可重用的类来构建页面。
- 这个概念很早就出现了，最近几年才出现这个词，并且开始流行起来。
- 原子化长什么样子？
-->


# Example


<!-- 
相信大家也都写过这样的代码，这就是原子化css的一个例子。
这样一个一个写比较麻烦，我们可以通过css预处理器来简化的编写。
-->


# Sass

<!-- 
 - 使用预处理的一些特性来批量生成，方便一些
 既然聊到了原子化，就提一提原子性的优缺点。
-->



# Advantages

<!-- 
- 已拆分至最小单元，能够最大程度的复用，同时又因为足够小，针对单个的样式修改不会影响到其他的样式，维护性也很好。
- 降低css打包体积，网络传输的时间减少，同时也减少了浏览器解析css的时间。
- 就近编写样式，不需要去单独的标签，或者单独的样式文件去编写样式，提升开发者体验。
 -->

# Disadvantages


<!-- 
 - 理解和使用原子化 CSS 可能需要一些时间和学习成本。与传统的基于选择器的 CSS 相比，这种模式需要适应新的思维方式和工作流程。 
 - 处理复杂的布局时，代码会变成冗长，不利于阅读。（如何去规避成为了一个问题？）
 - 随着时间的迭代，会变得难以管理，因为我们不知道哪些是可以删除的，哪些是不可以删除的。
-->


# A question


<!-- 
我们介绍了上面两种使用原子化css的方式，但是存在
一个大问题，不管手动去写样式，还是通过预处理去批量生成css, 都需要自己去写，
就算自己写，有时候也写不完，因为样式属性跟属性值组合太多了。


所以有没有一种方式，能够自动的去生成样式呢？
同时，能不能帮我们管理好css，比如说让我们知道那些是可以删除的。

当然时有的，我们就要提到一些原子化css框架。
-->

# Atomic css frameworks 


# Frameworks(框架)
<!-- 
 - 2017年左右，Tailwind css最先出来，因其独特的方式而受到欢迎。
 - 后来vite的出现，在vite中使用，会全量编译css，甚至会出现M级别的数据，会造成性能问题。同时也不符合vite的哲学。所以，后面出现了按需编译的Windi css。
 - unocss 受到了Tailwind css 和 Windi css的启发，在这些基础上，给到了更多的自定义的能力。

 - 后来，Tailwind css 也实现了按需编译和属性模式，Windi css就没有了优势，所以后面就没有继续维护了。 

 - 所以我们就来看看，Tailwind css 和 UnoCss的区别。
-->


# Tailwind Css vs UnoCss
<!-- 
 Tailwind css
 - 是一个postcss插件，对Postcss有所依赖。
 - 发展的很好，成为了一个独立公司。

 Unocss 

 - 采用正则匹配，在TailWind css没有实现JIT之前, 快200倍+，实现之后，也快5倍左右。
 - 全量可定制，灵活性很高。
 - 正是由于零依赖，可以实现cdn runtime build, 可以直接在浏览器里面使用，不依赖于任何打包器。
  - 预设兼容Tailwind css

  基于此，这次分享我选择了Unocss。
  下面我们来看看Unocss的一些特性。
-->

# Introducing

# Unocss Core Features(核心特性)

# Install (安装)


# Rules (规则)

<!-- 
规则：
- 通过正则匹配，生成自定义样式。

当然我们一个一个写还是太麻烦了，我们可以通过预设来实现。 
-->



# Presets (预设)

<!-- 
Presets

- 通过预设，可以快速的使用一些常用的样式。
- 包含一些官方预设，还有一些社区预设。
- 当然自己也可以定义预设。
-->

# Shortcuts (快捷方式)
<!-- 
shortcuts

我们可能存在一些公共的样式，我们可以考虑使用快捷方式来实现。而不用每次都单独写。
-->

# Css Directives (Css指令)
<!-- 
css指令

有时候我么可能遇到在单个文件存在公共的样式，但是又不是全局的样式，我们可以考虑使用css指令来实现。
-->


# Attributify Mode (属性模式)

<!-- 
属性模式

有时候我们遇到复杂的布局的时候，样式可能会很长，难以阅读。
我们可以考虑使用属性模式来分类样式，这样可以更好的阅读。
-->


# Pure Css Icons (纯Css的图标)
<!-- 
纯css图标 

- 提供了几万+个图标，可以直接使用
- 按需引入
- 当然也可以自定义配置自己的svg图标
-->


# SafeList (安全列表)

<!-- 
safe list

有时候我们会遇到动态的样式，但是正则是不能够匹配运行时的样式的。
这个时候，我们可以考虑使用safe list来解决这个问题。
但是，还有一个限制是动态的样式有限的。因为你总不能可能去列举所有的可能性。

如果遇到这种情况，使用其他的方式更好一些，比如vue里面的计算属性。

-->



# Cli (命令工具)

<!-- 
cli 

应用的场景是什么呢？
比如说：在我们公司内部里面有对uniapp的使用，虽然uniapp提供了部分webpack的能力，我测试了一下，并不能够直接使用unocss。
但是我们可以使用unocss的cli来解决这个问题。

cli会去扫描定义的entry入口，然后通过正则去匹配，然后生成对应的css，写入到指定的文件，全局引入这个文件就可以生效了。


核心的特性介绍大致是这里内容，下面来讲一下一些开发技巧。
-->



# Tips


# Vscode extension(扩展)

<!-- 
Vscode extension

- 自动补全
-->


<!-- 
Vscode extension

- 组合提示
-->

# Inspector (检查器)
<!-- 
检查器 

借助一些打包器，可以在开发环境下使用检查器
能够查看生成的样式
-->


# Docs

<!--
- unocss有一个交互式文档
- 甚至可以去看Tailwind，因为unocss内置的规则兼容了tailwind css， 去看tailwind其实有一个好处，以后你想使用tailwind css的时候，基本可以无缝切换。
-->


# Conclusion 


<!-- 

到这里以上是这次分享的全部内容，当然里面的内容并不全，只是简单提了一下，
最主要的还是让大家有一个概念，后面有机会的时候可以自己去尝试一下。

如果你想了解更多，可以看看官方文档。

同时，原子化css并不是万能的，它只是一种解决方案，有时候其他的解决方式可能更加快捷有效。

下面就是QA环节。
-->


# Q&A















